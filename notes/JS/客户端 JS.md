## 内存机制

### 数据是如何存储的

一言以蔽之：基本数据类型用栈存储，引用数据类型用堆存储

对于<u>赋值</u>操作，原始类型的数据直接完整地赋值变量值，对象数据类型的数据则是复制引用地址



### V8引擎的垃圾内存回收

**V8内存限制**

在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，<u>在64位系统下，V8最多只能分配1.4G</u>，在32位系统中，最多只能分配0.7G。在前端这样的大内存需求其实并不大，但对于后端而言，node.js如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。

对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了。

V8 要为**堆内存**设置内存上限，是由两个因素所共同决定的：<u>JS单线程的执行机制、JS垃圾回收机制的限制</u>

JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停；另一方面垃圾回收其实是非常耗时间的操作，在这么长的时间内，JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存

**新生代内存的回收**

V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。

新生代的内存默认限制在 64 位和 32 位系统下分别为 32MB 和 16MB。新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。

```
// 这是调整新生代这部分的内存，单位是KB
node --max-new-space-size=2048 xxx.js
```

1. 首先将新生代内存空间一分为二：From、To，其中From部分表示正在使用的内存，To 是目前闲置的内存

2. 当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中（在To内存中按照顺序从头放置），如果是非存活对象直接回收即可
3. 当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。

> 由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做**内存碎片**。新生代垃圾回收算法也叫**Scavenge算法**。
>
> Scavenge 算法主要就是解决内存碎片的问题，不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

**老生代内存的回收**

新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。触发晋升：

- 已经经历过一次 Scavenge 回收
- To（闲置）空间的内存占用超过25%

```
// 这是调整老生代这部分的内存，单位是MB
node --max-old-space-size=2048 xxx.js
```

1. 进行标记-清除：主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中<u>使用的变量</u>以及被<u>强引用</u>的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收
2. 整理内存碎片：V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。

**增量标记**

由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，<u>即将一口气完成的标记任务分为很多小的部分完成</u>，每做完一个小的部分就"歇"一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像。

经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。



## 执行中

### V8执行JS过程

将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:

- 通过词法分析和语法分析生成 <u>AST(抽象语法树)</u>
- 生成字节码

然后解释器根据字节码来执行程序，但 JS 整个执行的过程其实会比这个更加复杂。

1. **生成AST**

   分为两步——词法分析和语法分析

   词法分析即分词，它的工作就是将一行行的代码分解成一个个token

   接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST

   举个例子：

   ```javascript
   let name = 'sanyuan'
   console.log(name)
   ```

   最后生成的 AST 是这样的:

   ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OFeiaAoahHJIu24bMkhdo0CGkxibHqSHFmibsuV8kGTDGibB4tsiaOibCEibnVyAElJagvX3YbBZEjqhxDicfWpibJMYicrQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码

   > babel 的工作原理就是将ES5 的代码解析生成ES5的AST，然后将ES5 的 AST 转换为 ES6 的AST，最后才将 ES6 的 AST 转化为具体的 ES6 代码（荒山的babel文章）

   生成 AST 后，接下来会生成执行上下文

2. **生成字节码**

   生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是字节码并不能让机器直接运行

   >字节码是介于AST 和机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行
   >
   >在 V8 的早期直接把 AST 转换成机器码，但后来因为机器码的体积太大，引发了严重的内存占用问题，字节码是比机器码轻量得多的代码

   字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。

3. **执行代码**

   由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率

   在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做**热点代码**(`HotSpot`)，然后将其编译成机器码保存起来，这个用来编译的工具就是V8的编译器（也叫做`TurboFan`，编译器和解释器的根本区别在于前者会编译生成二进制文件但后者不会），因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。

   这种字节码跟编译器和解释器结合的技术，我们称之为**即时编译**, 也就是我们经常听到的`JIT`。



### `EventLoop`

#### 宏任务(`MacroTask`)

在 JS 中，大部分的任务都是在主线程上执行，为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种**队列**的方式来存储这些任务，常见的任务有：

- 普通任务队列：渲染事件、用户交互事件、JS脚本执行、I/O （网络请求、文件读写完成事件等等）、DOM事件的处理函数（handler / listener）
- 延迟队列：专门处理诸如`setTimeout` / `setInterval`这样的定时器回调任务

#### 微任务(`MicroTask`)

其实引入微任务的初衷是为了解决异步回调的问题：将异步回调放到当前宏任务的末尾

> 如果将异步回调进行宏任务队列的入队操作，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿

在每一个宏任务中定义一个**微任务队列**，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。

常见的微任务有`MutationObserver`、`Promise.then`(或.reject) 以及以 Promise 为基础开发的其他技术（比如fetch API）、`async` / `await`中`await`的内容、V8 的垃圾回收过程

#### 浏览器环境下

1. 一开始整段脚本作为第一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有Web worker任务，有则执行
6. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

#### Node.js 环境下

`nodejs`的event是基于**`libuv`**的，而浏览器的event loop则在html5的规范中明确定义。
`libuv`已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。

**event loop**是`libuv`的核心所在，` js` 会把回调和任务交给`libuv`，`libuv`何时来调用回调就是 event loop 来控制的

event loop 首先会在内部维持多个<u>事件队列（或者叫做观察者 watcher）</u>，比如时间队列、网络队列等等，使用者可以在watcher中注册回调，当事件发生时事件转入pending状态，再下一次循环的时候按顺序取出来执行，而`libuv`会执行一个相当于 while true的无限循环，不断的检查各个watcher上面是否有需要处理的pending状态事件，如果有则按顺序去触发队列里面保存的事件，同时由于`libuv`的事件循环<u>每次只会执行一个回调</u>，从而避免了 竞争的发生。

`Libuv`的 event loop执行图：

![图片描述](https://segmentfault.com/img/bVbaNie?w=444&h=461)

**三大关键阶段**

1. **`timer`**：执行定时器回调的阶段。检查定时器，如果到了时间，就执行回调，这些定时器就是`setTimeout`、`setInterval`

2. `I/O callbacks`：当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。

3. 空闲、预备状态（第2阶段结束，poll未触发之前）

4. **`poll`**：轮询阶段。因为在node代码中难免会有异步操作，比如文件I/O、网络I/O等等，当这些异步操作做完了，就会来通知JS主线程，就是通过'data'、 'connect'等事件使得事件循环到达 `poll` 阶段。到达了这个阶段后：

   如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，`eventLoop` 将回到timer阶段；

   如果没有定时器, 会去看回调函数队列

   - 如果队列不为空，拿出队列中的方法依次执行

   - 如果队列为空，检查是否有 `setImmdiate` 的回调

   - - 有则前往check阶段
     - 没有则继续等待，相当于阻塞了一段时间（阻塞时间是有上限的），等待 `callback` 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。

5. **`check `**：直接执行 `setImmdiate` 的回调

6. `close callbacks`：在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 `socket.destroy()`， 'close' 事件的回调就会在这个阶段执行。

> **`nodejs` 和 浏览器关于`eventLoop`的主要区别**
>
> 两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而`nodejs`中的微任务是在不同阶段之间执行的。

#### `process.nextTick`

`process.nextTick` 是一个独立于 `eventLoop` 的任务队列。

在每一个 `eventLoop` 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<u>优先于微任务</u>执行。