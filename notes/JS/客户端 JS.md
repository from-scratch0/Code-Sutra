## 缓存

**缓存作用**

- 减少冗余的数据传输，节省网费
- 减少服务器的负担，大大提高网站性能
- 加快了客户端加载网页的速度

**缓存分类**

- 强制缓存 如果生效，不需要再和服务器发生交互

- 对比缓存 不管是否生效，都需要与服务器端发生交互

  两类缓存规则可以同时存在，强制缓存优先级高于对比缓存

### 强制缓存

强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据

在没有缓存数据时，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中

![强制缓存和对比缓存](C:/dev/CodeSutra/notes/Nodejs/src/cache.drawio.png)

### 对比缓存

对比缓存，需要进行比较判断是否可以使用缓存

浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中

再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返状态码，通知客户端比较成功，可以使用缓存数据

### 请求流程

**第一次请求**

浏览器请求 -> 无缓存 -> 向web服务器请求 -> 请求响应，缓存协商 -> 呈现

缓存协商：是否缓存Expires / Cache-Control、缓存时间、Etag、Last-Modified等

**第二次请求**

![HTTP缓存策略](C:/dev/CodeSutra/notes/Nodejs/src/request.drawio.png)

首先是检查*强缓存*，这个阶段不需要发送HTTP请求（通过相应字段检查）

强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是*协商缓存*

#### Expires / Cache-Control

浏览器将文件缓存到<u>Cache目录</u>，第二次请求时浏览器会先检查Cache目录下是否含有该文件，如果有并且还没到

`HTTP/1.0`时期，使用的是Expires，而`HTTP/1.1`使用的是Cache-Control

```Expires```设置的时间，即文件还没有过期，此时浏览器将直接从缓存目录中读取文件，不再发送请求

**Expires**是服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前可以直接从浏览器缓存数据，而无需再次请求，这是HTTP1.0的内容，现在浏览器均默认使用HTTP1.0，所以基本可以忽略

潜藏了一个坑，那就是*服务器的时间和浏览器的时间可能并不一致*，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。

**Cache-Control**与```Expires```的作用一致，都是指明当前资源的有效期，但是它采用过期时长来控制缓存，控制浏览器是否直接从缓存取数据还是重新给服务器发请求取数据，*优先级高于```Expires```*

> ```private``` 只有浏览器客户端可以缓存 中间的代理服务器不能缓存
>
> ```public``` 客户端和代理服务器都可以缓存
>
> ```max-age=60``` 缓存内容将在60秒后失效
>
> ```no-cache``` 需要使用对比缓存验证数据，强制向源服务器再次验证（禁用强制缓存 代理服务器）
>
> ```no-store``` 所有内容都不会缓存，强制缓存和对比缓存都不会触发
>
> ```s-maxage``` 限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的`max-age`并不冲突

[expires](server/cache/expires.js)

#### Last-Modified / Etag

**通过最后修改时间来判断缓存是否可用**

1. ```Last-Modified```：响应时告诉客户端此资源的最后修改时间
2. ```If-Modified-Since```：当资源过期时（使用Cache-Control标识的max-age），发现资源具有```Last-Modified```声明，则再次向服务器请求时带上头```If-Modified-Since```，这个字段的值也就是服务器传来的最后修改时间
3. 服务器收到请求后发现有头```If-Modified-Since```则与被请求资源的最后修改时间进行比对，若最后修改时间较新，说明资源又被改动过，则响应最新的资源内容并返回200状态码
4. 若最后修改时间和```If-Modified-Since```一样，说明资源没有修改，则响应304表示未更新，告知浏览器继续使用所保存的缓存文件

[最后修改时间](server/cache/lastmodify.js)

**存在的问题**

- 某些服务器不能精确得到文件的最后修改时间，这样就无法通过最后修改时间来判断文件是否更新了
- 某些文件的修改非常频繁，在秒一下的时间内进行修改，而```Last-Modified```只能精确到秒
- 一些文件的最后修改时间改变了，但是内容并未改变，不希望客户端认为这个文件修改了
- 如果同样的一个文件位于多个CDN服务器上的时候内容虽然一样，修改时间不一样

**ETag**

ETag是实体标签的缩写，根据实体内容生成的一段```hash```字符串，可以标识资源的状态，当资源发生变化时，ETag也随之发生变化

ETag是Web服务端产生的，发给浏览器客户端

1. 客户端想判断缓存是否可用，可以先获取缓存中文档的ETag，然后通过```If-None-Match```发送请求给Web服务器询问此缓存是否可用
2. 服务器收到请求，将服务器中此文件的ETag和请求头中的```If-None-Match```相比较，如果值是一样的，说明缓存还是最新的，Web服务器将发送```304 Not Modified```响应码给客户端表示缓存未修改过，可以使用
3. 如果不一样，则Web服务器将发送该文档的最新版本给浏览器客户端

[ETag](server/cache/etag.js)

- 在精准度上，`ETag`优于`Last-Modified`
- 在性能上，`Last-Modified`优于`ETag`：`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值
- 如果两种方式都支持的话，服务器会优先考虑`ETag`

### 缓存位置

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

**Service Worker**

Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`

虽然如此，它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 **Service Worker Cache**。

Service Worker 同时也是 PWA 的重要实现机制

**Memory Cache / Disk Cache**

*Memory Cache*指的是内存缓存，从效率上讲它是最快的，但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了

*Disk Cache*就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是它的优势在于存储容量和存储时长

- 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
- 内存使用率比较高的时候，文件优先进入磁盘

**Push Cache**

即推送缓存，这是浏览器缓存的最后一道防线

它是 `HTTP/2` 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛



## 内存机制

### 数据是如何存储的

一言以蔽之：基本数据类型用栈存储，引用数据类型用堆存储

对于<u>赋值</u>操作，原始类型的数据直接完整地赋值变量值，对象数据类型的数据则是复制引用地址



### V8引擎的垃圾内存回收

**V8内存限制**

在其他的后端语言中，如Java/Go, 对于内存的使用没有什么限制，但是JS不一样，V8只能使用系统的一部分内存，具体来说，<u>在64位系统下，V8最多只能分配1.4G</u>，在32位系统中，最多只能分配0.7G。在前端这样的大内存需求其实并不大，但对于后端而言，node.js如果遇到一个2G多的文件，那么将无法全部将其读入内存进行各种操作了。

对于栈内存而言，当ESP指针下移，也就是上下文切换之后，栈顶的空间会自动被回收。但对于堆内存而言就比较复杂了。

V8 要为**堆内存**设置内存上限，是由两个因素所共同决定的：<u>JS单线程的执行机制、JS垃圾回收机制的限制</u>

JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停；另一方面垃圾回收其实是非常耗时间的操作，在这么长的时间内，JS代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的选择，那就是限制堆内存

**新生代内存的回收**

V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。

新生代的内存默认限制在 64 位和 32 位系统下分别为 32MB 和 16MB。新生代中的变量存活时间短，来了马上就走，不容易产生太大的内存负担，因此可以将它设的足够小。

```
// 这是调整新生代这部分的内存，单位是KB
node --max-new-space-size=2048 xxx.js
```

1. 首先将新生代内存空间一分为二：From、To，其中From部分表示正在使用的内存，To 是目前闲置的内存

2. 当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中（在To内存中按照顺序从头放置），如果是非存活对象直接回收即可
3. 当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。

> 由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配，这种零散的空间也叫做**内存碎片**。新生代垃圾回收算法也叫**Scavenge算法**。
>
> Scavenge 算法主要就是解决内存碎片的问题，不过Scavenge 算法的劣势也非常明显，就是内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀。

**老生代内存的回收**

新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。触发晋升：

- 已经经历过一次 Scavenge 回收
- To（闲置）空间的内存占用超过25%

```
// 这是调整老生代这部分的内存，单位是MB
node --max-old-space-size=2048 xxx.js
```

1. 进行标记-清除：主要分成两个阶段，即标记阶段和清除阶段。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中<u>使用的变量</u>以及被<u>强引用</u>的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收
2. 整理内存碎片：V8 的解决方式非常简单粗暴，在清除阶段结束后，把存活的对象全部往一端靠拢。由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。

**增量标记**

由于JS的单线程机制，V8 在进行垃圾回收的时候，不可避免地会阻塞业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。那这个时候为了避免这样问题，V8 采取了增量标记的方案，<u>即将一口气完成的标记任务分为很多小的部分完成</u>，每做完一个小的部分就"歇"一下，就js应用逻辑执行一会儿，然后再执行下面的部分，如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟React Fiber的思路有点像。

经过增量标记之后，垃圾回收过程对JS应用的阻塞时间减少到原来了1 / 6, 可以看到，这是一个非常成功的改进。



### 内存管理

**标记清除**：垃圾收集器在运行时会给存在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。这是还被加上了标记的变量则被视为准备删除的变量

**引用计数**：跟踪记录每个值被引用的次数，释放引用次数为0的值的内存 <u>循环引用问题</u>

将内存占用量保持在一个较小的值可以让页面性能更好，优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。将不必要的数据设置为`null`即为解除引用，确保其不在执行上下文中，因此在下次垃圾回收时会被回收

- `const`和`let`声明

  在块作用域比函数作用域更早终止的情况下能更早地让垃圾回收程序介入

- 隐藏类和删除操作

  V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征，能够共享相同隐藏类的对象性能会更好

  避免“先创建再补充”式的动态属性赋值，并在构造函数中一次性声明所有属性

  动态删除属性与动态添加属性导致的后果一样，把不想要的属性设置为null

- 内存泄漏

  - 意外声明全局变量

  - 定时器的回调通过闭包引用了外部变量

  - JS闭包

    闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量

    利用闭包可以突破作用链域

    闭包的特性：

    - 函数内再嵌套函数
    - 内部函数可以引用外层的参数和变量
    - 参数和变量不会被垃圾回收机制回收
- 优点：能够实现封装和缓存等
    
    - 缺点：消耗内存、使用不当会内存溢出，
- <u>解决方法</u>：在退出函数之前，将不使用的局部变量全部删除
  
- `WeakSet` 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏
  
- 静态分配和对象池



## 执行中

### V8执行JS过程

将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:

- 通过词法分析和语法分析生成 <u>AST(抽象语法树)</u>
- 生成字节码

然后解释器根据字节码来执行程序，但 JS 整个执行的过程其实会比这个更加复杂。

1. **生成AST**

   分为两步——词法分析和语法分析

   词法分析即分词，它的工作就是将一行行的代码分解成一个个token

   接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST

   举个例子：

   ```javascript
   let name = 'sanyuan'
   console.log(name)
   ```

   最后生成的 AST 是这样的:

   ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/OFeiaAoahHJIu24bMkhdo0CGkxibHqSHFmibsuV8kGTDGibB4tsiaOibCEibnVyAElJagvX3YbBZEjqhxDicfWpibJMYicrQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码

   > babel 的工作原理就是将ES5 的代码解析生成ES5的AST，然后将ES5 的 AST 转换为 ES6 的AST，最后才将 ES6 的 AST 转化为具体的 ES6 代码（荒山的babel文章）

   生成 AST 后，接下来会生成执行上下文

2. **生成字节码**

   生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是字节码并不能让机器直接运行

   >字节码是介于AST 和机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行
   >
   >在 V8 的早期直接把 AST 转换成机器码，但后来因为机器码的体积太大，引发了严重的内存占用问题，字节码是比机器码轻量得多的代码

   字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。

3. **执行代码**

   由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率

   在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做**热点代码**(`HotSpot`)，然后将其编译成机器码保存起来，这个用来编译的工具就是V8的编译器（也叫做`TurboFan`，编译器和解释器的根本区别在于前者会编译生成二进制文件但后者不会），因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。

   这种字节码跟编译器和解释器结合的技术，我们称之为**即时编译**, 也就是我们经常听到的`JIT`。



### `EventLoop`

#### 来源

JS 执行栈和渲染线程是**相互阻塞**的，本质上因为 JS 太灵活了，它可以去获取 DOM 中的诸如坐标等信息。 如果两者同时执行，就有可能发生冲突，比先获取了某一个 DOM 节点的 x 坐标，下一时刻坐标变了， JS 又用这个“旧的”坐标进行计算然后赋值给 DOM，冲突便发生了。 解决冲突的方式有两种：

1. 限制 JS 的能力，只能在某些时候使用某些 API，这种做法极其复杂，还会带来很多使用不便
2. JS 和渲染线程不同时执行就好了，一种方法就是现在广泛采用的相互阻塞，实际上这也是目前浏览器广泛采用的方式

V8 只负责 JS 代码的编译执行，给 V8 一段 JS 代码，它就从头到尾一口气执行下去，中间不会停止

假设我们需要获取用户信息，获取用户的文章，获取用户的朋友

- 单线程无异步

  上面三个请求都是同步执行的；最可怕的是JS执行栈和渲染线程是相互阻塞的，因此用户就在这期间根本无法操作，界面无法响应，这显然是无法接受的

- 多线程无异步

  虽然三个接口仍然需要采用同步方式，但是可以将代码分别在多个线程执行

  由于三块代码同时执行，因此总的时间最理想的情况下取决与最慢的时间；由于三个线程都可以对 DOM 和堆内存进行访问，因此很有可能会冲突，就需要借助于诸如锁来解决，相应地编程模型也会更复杂

- 单线程 + 异步

  如何实现异步——事件循环

事件循环就是用来做调度的，浏览器和NodeJS中的事件循坏就好像操作系统的调度器一样，只不过调度的对象变成了 JS 的执行。操作系统的调度器决定何时将什么资源分配给谁。对于有线程模型的计算机，那么操作系统执行代码的最小单位就是线程，资源分配的最小单位就是进程，代码执行的过程由操作系统进行调度。

事件循环之所以可以实现异步，是因为碰到异步执行的代码，浏览器会将用户注册的回调函数存起来，然后继续执行后面的代码。等到未来某一个时刻，“异步任务”完成了，会触发一个事件，浏览器会将“任务的详细信息”作为参数传递给之前用户绑定的回调函数。具体来说，就是将用户绑定的回调函数推入浏览器的执行栈。

#### 宏任务(`MacroTask`)

在 JS 中，大部分的任务都是在主线程上执行，为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种**队列**的方式来存储这些任务，常见的任务有：

- 普通任务队列：渲染事件、用户交互事件、JS脚本执行、I/O （网络请求、文件读写完成事件等等）、DOM事件的处理函数（handler / listener）
- 延迟队列：专门处理诸如`setTimeout` / `setInterval`这样的定时器回调任务

#### 微任务(`MicroTask`)

其实引入微任务的初衷是为了解决异步回调的问题：将异步回调放到当前宏任务的末尾

> 如果将异步回调进行宏任务队列的入队操作，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿

在每一个宏任务中定义一个**微任务队列**，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。

常见的微任务有`MutationObserver`、`Promise.then`(或.reject) 以及以 Promise 为基础开发的其他技术（比如`fetch API`）、`async` / `await`中`await`的内容、V8 的垃圾回收过程

#### 浏览器环境下

1. 一开始整段脚本作为第一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有Web worker任务，有则执行
6. 执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

#### Node.js 环境下

`nodejs`的event是基于**`libuv`**的，而浏览器的event loop则在html5的规范中明确定义。
`libuv`已经对event loop作出了实现，而html5规范中只是定义了浏览器中event loop的模型，具体实现留给了浏览器厂商。

**event loop**是`libuv`的核心所在，` js` 会把回调和任务交给`libuv`，`libuv`何时来调用回调就是 event loop 来控制的

event loop 首先会在内部维持多个<u>事件队列（或者叫做观察者 watcher）</u>，比如时间队列、网络队列等等，使用者可以在watcher中注册回调，当事件发生时事件转入pending状态，再下一次循环的时候按顺序取出来执行，而`libuv`会执行一个相当于 while true的无限循环，不断的检查各个watcher上面是否有需要处理的pending状态事件，如果有则按顺序去触发队列里面保存的事件，同时由于`libuv`的事件循环<u>每次只会执行一个回调</u>，从而避免了 竞争的发生。

`Libuv`的 event loop执行图：

![图片描述](https://segmentfault.com/img/bVbaNie?w=444&h=461)

**三大关键阶段**

1. **`timer`**：执行定时器回调的阶段。检查定时器，如果到了时间，就执行回调，这些定时器就是`setTimeout`、`setInterval`

2. `I/O callbacks`：当第 1 阶段结束后，可能并不会立即等待到异步事件的响应，这时候会进入到 I/O异常的回调阶段。比如说 TCP 连接遇到ECONNREFUSED，就会在这个时候执行回调。

3. 空闲、预备状态（第2阶段结束，poll未触发之前）

4. **`poll`**：轮询阶段。因为在node代码中难免会有异步操作，比如文件I/O、网络I/O等等，当这些异步操作做完了，就会来通知JS主线程，就是通过'data'、 'connect'等事件使得事件循环到达 `poll` 阶段。到达了这个阶段后：

   如果当前已经存在定时器，而且有定时器到时间了，拿出来执行，`eventLoop` 将回到timer阶段；

   如果没有定时器, 会去看回调函数队列

   - 如果队列不为空，拿出队列中的方法依次执行

   - 如果队列为空，检查是否有 `setImmdiate` 的回调

   - - 有则前往check阶段
     - 没有则继续等待，相当于阻塞了一段时间（阻塞时间是有上限的），等待 `callback` 函数加入队列，加入后会立刻执行。一段时间后自动进入 check 阶段。

5. **`check `**：直接执行 `setImmdiate` 的回调

6. `close callbacks`：在 check 阶段结束后还会进入到 关闭事件的回调阶段。如果一个 socket 或句柄（handle）被突然关闭，例如 `socket.destroy()`， 'close' 事件的回调就会在这个阶段执行。

> **`nodejs` 和 浏览器关于`eventLoop`的主要区别**
>
> 两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而`nodejs`中的微任务是在不同阶段之间执行的。

#### `process.nextTick`

`process.nextTick` 是一个独立于 `eventLoop` 的任务队列。

在每一个 `eventLoop` 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务<u>优先于微任务</u>执行。



## 事件

**事件**就是用户或浏览器自身执行的某种动作，如鼠标点击事件 `onclick`、页面的滚动事件 `onscroll` 等等，可以向文档或者文档中的元素添加**事件处理程序**（事件侦听器）来预订事件，即响应某个事件的函数

不管是浏览器还是 Nodejs 都是事件驱动的，都有自己的事件模型

事件驱动通俗地来说就是`什么都抽象为事件`

- 一次点击是一个事件
- 键盘按下是一个事件
- 一个网络请求成功是一个事件
- 页面加载是一个事件
- 页面报错是一个事件
- ...

浏览器依靠事件来驱动APP运行下去，如果没有了事件驱动，那么APP会直接从头到尾运行完，然后结束，事件驱动是浏览器的基石。

### 事件流

事件流：从页面中接收事件的顺序，当发生一个事件的时候，浏览器会初始化一个事件对象，然后将这个事件对象按照一定的逻辑进行传播，这个逻辑就是事件传播机制

事件触发有三个阶段

- **事件捕获阶段**：为截获事件提供了机会。`window` 往事件触发处传播，遇到注册的捕获事件会触发（在事件到达预定目标之前捕获它）
- **处于目标阶段**：实际的目标接收到事件。传播到事件触发处时触发注册的事件
- **事件冒泡阶段**：可以在这个阶段对事件做出响应。从事件触发处往 `window` 传播，遇到注册的冒泡事件会触发（事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播）

在 DOM 标准事件模型中，事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行

> **如何让事件先冒泡后捕获**
>
> 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件

### 事件处理程序

- **HTML事件处理程序**

  扩展作用域，让事件处理程序无需引用其他元素就能访问其他元素字段

  很多HTML事件处理程序都会被封装在try-catch块中捕获错误

- **DOM0级事件处理程序**

  1. 获取要操作对象的引用
  2. 每个元素都有事件处理程序属性，将一个函数赋值给它

  该事件处理程序是在元素的作用域内运行 this->该元素

  删除事件处理程序：`事件处理程序属性 = null`

- **DOM2级事件处理程序**

  `addEventListener('事件名', 函数, )`

  `removeEventListener` 只能使用此方法移除，添加的匿名函数无法移除

  可以添加多个事件处理程序

### 事件对象

触发DOM上某个事件时，会产生一个事件对象event

在事件处理程序内部

`this === event.currentTarget` 处理事件的元素

`event.target` 事件的实际目标

`event.type`通过一个函数处理多个事件时

`event.preventDefault()`

`event.stopPropagation()`

`event.eventPhase` =2时，`this`、`target`、`currentTarget`相等

### 内存性能

#### 事件委托（代理）

- 事件处理程序过多：添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能（占用内存、必须事先指定所有事件处理程序而导致的DOM访问次数会延迟整个页面的交互就绪事件）；

  > 每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JS代码之间就会建立连接，这种连接越多，页面执行越慢

- 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

- 不需要给子节点注销事件，移除事件处理程序时更容易

事件委托指的是，不在事件的发生地（直接DOM）上设置监听函数，而是在DOM树上尽量最高的层次上设置监听函数，利用事件冒泡，祖先元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。

#### 移除事件处理程序

- 在文档中通过`innerHTML`替换移除带有事件处理程序的元素时，原来添加的事件处理程序仍与元素保持着引用关系，极有可能无法被当做垃圾回收，最好先手工移除事件处理程序
- 卸载页面之前，先通过`onunload`事件处理程序移除所有事件处理程序



## 网络请求

### Ajax 原理

`Ajax` 的原理简单来说是在用户和服务器之间加了—个中间层( AJAX 引擎)，通过`XmlHttpRequest` 对象来向服务器发异步请求，从服务器获得数据，然后用 `javascript`来操作 `DOM` 而更新页面，使用户操作与服务器响应异步化

`Ajax` 的过程只涉及 `JavaScript 、 XMLHttpRequest 和 DOM XMLHttpRequest` 是`ajax`的核心机制

`axios`：

- 从浏览器中创建 `XMLHttpRequest`
- 从 `node.js` 发出 `http` 请求
- 支持 `Promise API`
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- 自动转换 `JSON` 数据
- 客户端支持防止 `CSRF/XSRF`

### Fetch API

`Fetch`是基于promise设计的，fetch不是ajax的进一步封装，没有使用`XMLHttpRequest`对象，用于在 JavaScript 脚本里面发出 HTTP 请求，浏览器原生提供这个对象

`fetch()`的功能与 `XMLHttpRequest` 基本相同，但有三个主要的差异：

1. `fetch()`使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁
2. `fetch()`采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，`XMLHttpRequest` 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码
3. `fetch()`通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用；`XMLHTTPRequest` 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来

`fetch()`接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象，`fetch()`接收到的`response`是一个 [Stream 对象]

### 解决跨域

#### CORS

其实是 W3C 的一个标准，全称是跨域资源共享。它需要浏览器和服务器的共同支持

浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于**简单请求**:

- 请求方法为 GET、POST 、HEAD
- 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)

**简单请求**

请求发出去之前，浏览器会自动在请求头当中，添加一个**`Origin`**字段，用来说明请求来自哪个源，服务器拿到请求之后，在回应时对应地添加**`Access-Control-Allow-Origin`**字段，如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截

**Access-Control-Allow-Credentials**字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为`true`, 并且在前端也需要设置**`withCredentials`**属性:

```javascript
let xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

**Access-Control-Expose-Headers**用来确定XHR对象中`getResponseHeader()`方法中能获得的额外信息

**非简单请求**

发送请求前先使用`OPTIONS`方法向服务器发送一个**预检请求**

```http
OPTIONS / HTTP/1.1
Origin: 当前地址
Host: xxx.com
Access-Control-Request-Method: 请求希望使用的方法
Access-Control-Request-Headers: 逗号分隔的自定义头部列表
```

服务器响应：

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000 // 缓存预检请求的秒数
```

在预检请求的响应返回后，如果请求不满足响应头的条件，则触发`XMLHttpRequest`的`onerror`方法，当然后面真正的CORS请求也不会发出去了

到了真正的 CORS 请求，和简单请求的情况是一样的，浏览器自动加上`Origin`字段，服务端响应头返回Access-Control-Allow-Origin

只有第一次发送这种类型的请求时才会多发送一次额外的HTTP请求



#### JSONP

原理就是利用 `<script>` 标签没有跨域限制的漏洞。通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时

使用简单且兼容性好；请求方法单一，只支持 GET 请求

封装一个 JSONP:

```javascript
const jsonp = ({ url, params, callbackName }) => {
  const generateURL = () => {
    let dataStr = '';
    for(let key in params) {
      dataStr += `${key}=${params[key]}&`;
    }
    dataStr += `callback=${callbackName}`;
    return`${url}?${dataStr}`;
  };
    
  return new Promise((resolve, reject) => {
    // 初始化回调函数名称
    callbackName = callbackName || Math.random().toString.replace(',', '');
    // 创建 script 元素并加入到当前文档中
    let scriptEle = document.createElement('script');
    scriptEle.src = generateURL();
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callbackName] = (data) => {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    }
  });
}
```

当然在服务端也会有响应的操作, 以 express 为例:

```javascript
let express = require('express')
let app = express()
app.get('/', function(req, res) {
  let { a, b, callback } = req.query
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
})
app.listen(3000)
```

前端这样简单地调用一下就好了:

```javascript
jsonp({
  url: 'http://localhost:3000',
  params: {
    a: 1,
    b: 2
  }
}).then(data => {
  // 拿到数据进行处理
  console.log(data); // 数据包
})
```



#### Nginx

Nginx 是一种高性能的反向代理服务器

反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的**负载均衡**，换句话说，反向代理帮**其它的服务器**拿到请求，然后选择一个合适的服务器，将请求转交给它

比如说现在客户端的域名为client.com，服务器的域名为server.com

 Nginx 登场了，通过下面这个配置:

```javascript
server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
```

Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程



## 模块

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 `CommonJS` 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 `CommonJS `和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

### `<script>`

- <u>默认情况下</u>，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到`<script>`标签就会停下来，等到执行完脚本，再继续向下渲染，如果是外部脚本，还必须加入脚本下载的时间

```html
<script src="path/to/myModule.js" defer></script>
<script src="path/to/myModule.js" async></script>
```

- `<script>`标签打开**`defer`或`async`属性**，脚本就会异步加载：渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令

  `defer`与`async`的区别是：`defer`要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。即`defer`是“渲染完再执行”，`async`是“下载完就执行”。另外，如果有多个`defer`脚本，会按照它们在页面出现的顺序加载，而多个`async`脚本是不能保证加载顺序的。

- 浏览器加载 **ES6 模块**，也使用`<script>`标签，但是要加入**`type="module"`**属性

  浏览器对于带有`type="module"`的`<script>`，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了`<script>`标签的`defer`属性；如果网页有多个`<script type="module">`，它们会按照在页面出现的顺序依次执行

  `<script>`标签的`async`属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行，执行完成后，再恢复渲染；一旦使用了`async`属性，`<script type="module">`就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块

### ES6模块与`CommonJS`

- `CommonJS` 模块是 Node.js 专用的，与 ES6 模块不兼容；**语法上**两者最明显的差异是，`CommonJS` 模块使用`require()`和`module.exports`，ES6 模块使用`import`和`export`

- **`CommonJS` 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用**

  `CommonJS` 模块输出的是值的拷贝，也就是说一旦输出一个值，模块内部的变化就影响不到这个值；模块实现缓存，当第一次加载一个模块之后，会缓存这个模块的exports对象，以后如果再次加载，则直接从缓存中取，不需要再次加载

  ES6 模块的运行机制与 `CommonJS` 不一样：JS 引擎对脚本静态分析的时候，遇到模块加载命令**`import`**，就会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值，因此ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块；换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，输入的模块变量是只读的，对它进行重新赋值会报错，这就好比创造了一个`const`变量，可以添加属性但不能重新复制；**`export`**通过接口，输出的是同一个值，不同的脚本加载这个接口，得到的都是同一个实例

- **`CommonJS` 模块是运行时加载，ES6 模块是编译时输出接口**

  `CommonJS` 和 AMD 模块，都只能在运行时确定模块的依赖关系，以及输入和输出的变量。`CommonJS` 模块加载实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`，即`module.exports`属性），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”，输入时必须查找对象属性。

  ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 `CommonJS`模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

- **`CommonJS` 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异步加载**，有一个独立的模块依赖的解析阶段

### Node.js模块加载

Node.js 要求 ES6 模块采用**`.mjs`**后缀文件名，也就是说，只要脚本文件里面使用`import`或者`export`命令，那么就必须采用`.mjs`后缀名，Node.js 遇到`.mjs`文件，就认为它是 ES6 模块

> 如果不希望将后缀名改成`.mjs`，可以在项目的`package.json`文件中，指定`type`字段为`module`，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块
> ```json
> {
>    	"type": "module"
> }
> ```

如果这时还要使用 `CommonJS` 模块，那么需要将 `CommonJS` 脚本的后缀名都改成**`.cjs`**，如果没有`type`字段，或者`type`字段为`commonjs`，则`.js`脚本会被解释成 `CommonJS` 模块

**总结**：`.mjs`文件总是以 ES6 模块加载，`.cjs`文件总是以 `CommonJS` 模块加载，`.js`文件的加载取决于`package.json`里面`type`字段的设置