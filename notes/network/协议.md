[TOC]



## 一、协议的概念和作用

- 为了让计算机能够通信 计算机需要定义通信规则 这些规则 就是协议
- 规则是多种 协议也有多种
- 协议就是数据封装格式+传输

服务+协议实现数据传输

- 摩尔斯电码



## 二、OSI七层模型

Open System Interconnection 适用于所有的网络

- 分工带来效能

  将复杂的流程分解为几个功能相对单一的子进程

  整个流程更加清晰，复杂问题简单化

  更容易发现问题并针对性的解决问题



- 应用层（Application）：网络服务于最终用户的接口
- 表示层（Presentation）：数据的表示、安全、压缩
- 会话层（Session）：建立、管理、中止会话
- 传输层（Transmission）：定义传输数据的协议端口号，以及流控和差错校验（PC）
- 网络层（Network）：进行逻辑地址寻址，实现不同网络之间的路径选择（路由器）
- 数据链路层（Datalink）：建立逻辑连接，进行硬件地址寻址、差错校验等功能（交换机 类似流）
- 物理层（Physics）：提供机械、电气、功能和过程特性（网卡、网线、双绞线、同轴电缆、中继器）



## 三、TCP / IP参考模型

TCP / IP是传输控制协议 / 网络互联协议的简称

早期的TCP / IP模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层，后来在使用过程中，借鉴OSI七层参考模型，将网络接口层划分为物理层和数据链路层，形成**五层结构**

由网络层的IP协议和传输层的TCP协议组成，是一个很大的协议集合

物理层和数据链路层没有定义任何特定协议，支持所有的标准和专用的协议

**网络层**定义了网络互联也就是IP协议

- 网际协议IP（Internet Protocol）负责主机和网络之间寻址和路由数据包
- 地址解析协议ARP（Address Resolution Protocol）获得同一物理网络中的硬件主机MAC地址
- 反向地址转换协议（Reverse ~）允许局域网的物理机器从网关服务器的ARP表或者缓存上请求IP地址
- 网际控制消息协议ICMP（Internet Control Message Protocol）发送消息，并报告有关数据包的传送错误
- 互联组管理协议IGMP（Internet Group Management Protocol）IP主机向本地多路广播路由器报告主机组成员

**传输层**定义了TCP（传输控制协议）和UDP（用户数据包）协议

**应用层**定义了HTTP（超文本传输协议）、FTP（文件传输协议）、DNS（域名系统）等协议



### 1. 网络接口层

网络接口层是TCP/IP模型的最底层，负责接收从上一层交来的数据包并将数据包通过底层的物理网络发送出去，比较常见的就是*设备的驱动程序*，此层没有特定的协议，又分为物理层和数据链路层

#### 1.1 物理层

计算机在传递数据的时候传递的都是0和1的数字，物理层关心的是用什么信号来表示0和1，是否可以双向通信（双工、单工、半双工），最初的连接如何建立以及完成连接如何终止，物理层为数据传输提供可靠的环境

为数据端设备提供传送数据的通路，传输数据：

- 激活物理连接，在连接的设备之间连接起来形成通路
- 传输数据，关心如何打包数据和控制传输速度
- 关闭物理连接

#### 1.2 数据链路层

数据链路层位于物理层和互联网层之间，用来向网络层提供数据，就是把源计算机网络层传过来的信息传递给目标主机

- 如何将数据组合成**数据帧（Frame）**，帧是数据链路层的传输单位
- 数据链路的建立、维护和拆除
- 帧包装、帧传输、帧同步
- 帧的差错恢复
- 流量控制

#### 1.3 MAC地址

在通信过程中是用内置在网卡内的地址来标识计算机身份的

MAC地址48位的二进制组成，通常分为6段（6个字节），用16进制表示 

前三个字节（24比特）为供应商标识，后三个字节为供应商对网卡的唯一编号‘

CISCO: 00-0d-28  IBM: 00-06-1b

每个网卡都有一个全球唯一的地址标识自己，不会重复



### 2. 网络层

位于传输层和网络接口层之间，用于把数据从源主机经过若干个中间节点传送到目标主机，并向传输层提供最基础的数据传输服务，它要提供路由和选址的工作

#### 2.1 选址

交换机是靠MAC来寻址的，而因为MAC地址无层次的，所以要靠IP地址来确认计算机的位置，这就是选址

先从IP地址找到局域网，再从MAC找到地址；MAC地址类似于个体，IP地址相当于具体地址，数据链路层是把IP解析成MAC

#### 2.2 路由

在能够选择的多条道路之间选择一条最短的路径就是路由的工作

#### 2.3 IP

##### 2.3.1 头部

IP地址的网络部分是由Internet地址分配机构来统一分配的，以保证IP的唯一性

全为1的IP即255.255.255.255，称为限制广播地址，若将其作为数据包的目标地址，可以理解为发送到所有网络的所有主机

全为0的IP即0.0.0.0，表示启动时的IP地址，含义为尚未分配时的IP地址

127是用来进行本机测试的，除了127.255.255.255外，其它的127开头的地址都代表本机

##### 2.3.2 分类

| **分类** |        1~8        |  9~16   |  17~24  | 25~32 | 每个网络中最大主机数量 |
| :------: | :---------------: | :-----: | :-----: | :---: | :--------------------: |
|   A类    |  0NNNNNNN(1~126)  |  Host   |  Host   | Host  |         2^24-2         |
|   B类    | 10NNNNNN(128~191) | Network |  Host   | Host  |         2^16-2         |
|   C类    | 110NNNNN(192~223) | Network | Network | Host  |         2^8-2          |

**公有地址和私有地址**

私有IP：

A类私有IP：10.0.0.0 ~ 10.255.255.255

B类私有IP：172.16.0.0 ~ 172.31.255.255

C类私有IP：192.168.0.0 ~ 192.168.255.255

其他范围的IP均为公有IP地址

##### 2.3.3 子网掩码

子网掩码（subnet mask）又称子网络遮罩，用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位。子网掩码不能单独存在，而必须结合IP地址一起使用

子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分

- 子网掩码也是32个二进制位
- 网络部分用1表示，主机部分用0表示——掩饰的是主机部分
- IP地址和子网掩码做逻辑与运算得到网络地址

A（255.0.0.0）、B（255.255.0.0）、C（255.255.255.0）三类地址有默认的子网掩码

如果不同的IP的网络部分相同，那么他们就在一个网络内



不同层中的称谓：

- 数据帧（Frame）：一种信息单位，它的起始点和目的点都是数据链路层
- 数据包（Packet）：一种信息单位，起始和目的地是网络层
- 段（Segment）：通常指起始点和目的地都是传输层的信息单元
- 消息（message）：指起始点和目的地都在网络层以上（常在应用层）的信息单元

TOS（IP头部中的服务类型）

8位，包括

| 3bit的优先权字段（000~111） | 4bit的TOS子字段 | 1bit未用位必须置0 |
| :-------------------------: | :-------------: | :---------------: |
|                             |                 |                   |



### 3. 传输层

位于应用层和网络接口层之间

- 是**面向连接**的（保证双向的接收和发送都是正常的）、

  可靠的**进程到进程**通信的（HTTP服务器启动一个进程监听） 协议

- TCP提供**全双工服务**，即数据可在同一时间双向传播

- TCP将若干个字节构成一个分组，此分组称为报文**段（Segment）**

**功能**：提供一种端到端的连接

**特点**：对可靠性要求高的上层协议，实现可靠性的保证（数据丢失、损坏的情况下如何保证可靠性，网络层只管传递数据，不关心成功与否）

**TCP（Transmission Control Protocol）**：传输控制协议；可靠的、面向连接的协议；传输效率低

**UDP（User Datagram Protocol）**：用户数据报协议；不可靠的、无连接的协议；传输效率高

**TCP功能**

- 将数据进行分段打包传输
- 对每个数据包编号控制顺序
- 运输中丢失、重发和丢弃处理
- 流量控制避免拥塞

#### 3.1 TCP数据包封装

 32位序列号TCP用序列号对数据包进行标记，以便在到达目的地后重新组装，假设当前序列号为s，发送数据长度为l，则下次发送数据时的序列号为s+l，在建立连接时通常由计算机生成一个随机数作为序列号的初始值

 ![tcp](src/tcp.drawio.png)

**控制位**：对TCP的连接、传输和断开进行指挥

- URG（urgent紧急位）：紧急信号
- ACK（acknowledgement确认位）：确认序列号有效位，表明该数据包包含确认信息

- PSH（push急迫位）：缓存区将满，立刻传入数据
- RST（reset重置位）：连接断了重新连接
- SYN（synchronous建立联机 同步序列号位）：TCP建立连接时设为1
- FIN（发送端完成位）：提出断开连接的一方把FIN置1表示要断开连接

**紧急指针**：仅在URG（urgent紧急位）控制位为1时有效，表示紧急数据的末尾在TCP数据部分中的位置，通常在暂时中断通信时使用（比如输入ctrl+C）

**窗口值**：说明本地可接收数据段的数目，这个值的大小是可变的，用来在TCP传输中进行流量控制。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。

**校验和**：用来做差错控制，TCP校验和的计算包括TCP首部、数据和其它填充字节。在发送TCP数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验和一致说明数据是正确的，否则将认为数据被破坏，接收端将丢弃该数据

#### 3.2 握手和断开

- TCP是面向连接的协议，它在源点和终点之间建立虚拟连接，而不是物理连接
- 在数据通信之前，发送端与接收端要先建立连接，等数据发送结束后，双方再断开连接
- TCP连接的每一方都是由一个IP地址和一个端口组成

三次握手

SYN

SYN、ACK

ACK

- 第一次：主机A通过一个标识为SYN标识位的数据段发送给主机B请求连接，通过该数据段告诉主机B希望建立连接，需要B应答，并告诉主机B传输的起始序列号
- 第二次：主机B用一个确认应答ACK和同步序列号SYN标示位的数据段来响应主机A，一是发送ACK告诉主机A收到了数据段，二是通知主机A从哪个序列号做标记
- 第三次：主机A确认收到了主机B的数据段并可以开始传输实际数据

四次断开

ACK、FIN

ACK

ACK、FIN

ACK

- 主机A发送FIN控制位发出断开连接的请求
- 主机B进行响应，确认收到断开连接请求
- 主机B提出反方向的关闭要求
- 主机A确认收到的主机B的关闭连接请求

#### 3.3 抓包

#### 3.4 UDP

UDP是一个无连接、不保证可靠性的传输层协议，即发送端不关心发送的数据是否到达目标主机、数据是否出错等，收到数据的主机也不会告诉发送方是否收到了数据，它的可靠性由上层协议来保障

首部结构简单，在数据传输时能实现最小的开销，如果进程想发送很短的报文而对可靠性要求不高可以使用

**应用**：QQ、视频软件、TFTP简单文件传输协议（短信）

##### 组播

所谓组播，就是将网络中同一业务类型进行逻辑上的分组，从某个socket端口上发送的数据只能被该组中的其他主机所接收，不被组外的任何主机接收

实现组播时，并不直接把数据发送给目标地址，而是将数据发送到组播主机，操作系统将把该数据组播给组内的其他所有成员

在网络中，使用D类地址作为组播地址，范围指224.0.0.0 ~ 239.255.255.255，分为三类：

- 局部组播地址：224.0.0.0 ~ 224.0.0.255 为路由协议和其他用途保留
- 预留组播地址：224.0.1.0 ~ 238.255.255.255 可用于全球范围或网络协议
- 管理权限组播地址：239.0.0.0 ~ 239.255.255.255 组织内部使用，不可用于Internet



#### 3.5 DNS服务器

##### 3.5.1 域名

| 名称类型 |                      说明                      |     实例      |
| :------: | :--------------------------------------------: | :-----------: |
|   根域   |      一般认为全球共有13台根逻辑域名服务器      | 单个句点（.） |
|  顶级域  | 用来指示某个国家/地区/组织使用的名称的类型名称 |     .com      |
| 第二层域 |         个人/组织在网上使用的注册名称          |    zol.com    |
|   子域   |           已注册的二级域名派生的域名           |  www.zol.com  |

| DNS域名  |   cn / ru   |   com    |   net    |   edu    |     Mil      |      gov       |
| :------: | :---------: | :------: | :------: | :------: | :----------: | :------------: |
| 组织类型 | 中国/俄罗斯 | 商业公司 | 网络公司 | 教育机构 | 军事政府机构 | 非军事政府机构 |

##### 3.5.2 DNS服务器

DNS（Domain Name Service）服务器进行域名和与之对应的IP地址转换的服务器

IP地址不易记忆；早期使用Hosts文件解析域名，主要名称重复、主机维护困难

DNS（Domain Name System）域名系统：分布式、层次性

##### 3.5.3 访问过程

| 客户端向本地域名服务器发出请求       | 访问www.163.com，求IP地址            |
| ------------------------------------ | ------------------------------------ |
| 本地DNS服务器向**DNS根服务器**发请求 | 根服务器回复本地服务器（.com）的地址 |
| 本地DNS服务器向**（.com域）**发请求  | 得到（163.com）的服务器地址          |
| 本地DNS服务器向**（163.com）**发请求 | 得到（www.163.com）的IP地址1.1.1.1   |
| 本地DNS服务器向**客户端**回复        | 域名（www.163.com）的IP地址是1.1.1.1 |



### 4. 应用层

#### 4.1 URI和URL

**URI**（Uniform Resource Identifier）是统一资源标识符，在某个规则下能把这个资源独一无二标示出来，比如人的身份证号，用来区分互联网上不同的资源

- Uniform 不用根据上下文来识别资源指定的访问方式
- Resource 可以标识的任何东西
- Identifier 表示可标识的对象

**URL**（Uniform Resource Location）是统一资源定位符，表示资源的地点，URL是使用浏览器访问WEB页面时需要输入的网页地址

- Uniform 不用根据上下文来识别资源指定的访问方式
- Resource 可以标识的任何东西
- Location 定位

> 格式：```scheme://usr:pwd@ host:port path ?query #fragment```

协议类型（登录信息） 服务器地址 服务器端口号 带层次的文件路径 查询字符串```key=val&key=val``` 片段标识符（锚点）

> 编码

URL 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
因此，URL引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。
如，空格被转义成了%20，三元被转义成了%E4%B8%89%E5%85%83。



#### 4.2 HTTP超文本传输协议

![http](src/http.drawio.png)

**长连接**

TCP连接复用，同一个TCP连接来传输多个HTTP请求，避免TCP连接建立时的三次握手开销，和初建TCP连接时传输窗口小的问题

**管线化**

##### 4.2.1 请求报文和响应报文

**请求报文**

```
POST /form/entry HTTP/1.1 // 请求行     
Host: hackr.jp // 请求首部字段
Connection: keep-alive // 通用首部
Content-Type: application/x-www-form-urlencoded // 实体首部
Content-Lenghth: 16 // 实体首部

name=ueno&age=37 // 内容实体
```

![请求报文](src/请求报文.drawio.png)

- 请求行
  - 方法
    - GET 获取资源
    - POST 向服务器端发送数据，传输实体主体
    - PUT 传输文件 修改数据
    - HEAD 获取报文首部
    - DELETE 删除文件
    - CONNECT  多用于HTTPS和Websocket 建立连接隧道 用于代理服务器
    - OPTIONS 询问支持的方法
    - TRACE 追踪传输路径
  - URL
  - 协议版本号

> GET 和 POST 有什么区别？

- 首先最直观的是语义上的区别。
- 从*缓存*的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从*编码*的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从*参数*的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从*幂等性*的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
- 从*TCP*的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)



**响应报文**

```
HTTP/1.1 200 OK // 响应行
Date: Sun, 20 Sep 2020 09:28:18 GMT // 通用首部字段
Content-Length: 362 // 实体首部
Content-Type: text/html // 实体首部

<html> // 主体
...
```

- 响应行
  - 协议版本
  - 状态码
  - 状态码的原因短语
- 响应头
- 响应体

##### 4.2.2 编码

HTTP可以在传输过程中通过编码提升传输效率，但是会消耗更多的CPU时间

**4.2.2.1 编码压缩**

发送文件时可以先用ZIP压缩功能后再发送文件

> 编码规范：gzip compress deflate identify

###### 4.2.2.2 分割发送的分块传输编码

**定长包体**

对于定长包体而言，发送端在传输的时候一般会带上```Content-Length```, 来指明包体的长度

```Content-Length```对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败

**不定长包体**
http 头部字段:

```
Transfer-Encoding: chunked
```

表示分块传输数据，设置这个字段后会自动产生两个效果:

- Content-Length 字段会被忽略
- 基于长连接持续推送动态内容

```Connection: keep-alive```之前的为响应行和响应头，后面的为响应体

响应体的结构

```
chunk长度（16进制）
内容
chunk长度（16进制）
内容
...
0

```

最后留有一个空行

**大容量数据**

传输大容量数据时，通过把数据分割成多块（chunk），能让浏览器逐步显示页面

见*获取部分内容的范围请求*

**4.2.2.3 多部分对象集合**

一份报文主体中可以包含多类型实体

使用```boundary```字符串来划分多部分对象指明的各类实体，在各个实体起始行之前插入```--```标记，多部分对象集合最后插入```--```标记

> ```multipart/form-data```
>
> ```multipart/byteranges 206(Partical Content)``` 断连续传

###### 4.2.2.4 获取部分内容的范围请求

为了实现中断恢复下载的需求以及处理大文件的传输，需要能下载指定下载的实体范围

**服务器要支持范围请求**就必须加上一个响应头```Accept-Ranges: none```用来告知客户端这边是支持范围请求的

**Range|Content-Range**

而对于客户端而言，它需要指定请求哪一部分，通过```Range```这个请求头字段确定，格式为```bytes=x-y```

> -0-499表示从开始到第 499 个字节。
> 500- 表示从第 500 字节到文件终点。
> -100表示文件的最后100个字节。

```
// 单段数据
Range: bytes=0-9
// 多段数据
Range: bytes=0-9, 30-39
```

服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回```416```错误码，否则读取相应片段，返回```206```状态码
同时，服务器需要添加```Content-Range```字段，这个字段的格式根据请求头中```Range```字段的不同而有所差异
具体来说，请求单段数据和请求多段数据，响应头是不一样的

```
// 对于单段数据的请求
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100 

i am xxxxx
```

```Content-Range```字段，0-9表示请求的返回，100表示资源的总大小

```
// 对于多段数据的请求
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--
```

对于多重范围的范围请求，响应会在首部字段标明```Content-Type: multipart/byteranges;boundary=```：

- 请求一定是多段数据请求

- 响应体中的分隔符是 

  在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上--表示结束

###### 4.2.2.5 处理表单数据的提交

在 http 中，有两种主要的表单提交的方式，体现在两种不同的```Content-Type```取值:

- ```application/x-www-form-urlencoded```
- ```multipart/form-data```

对于```application/x-www-form-urlencoded```格式的表单内容，数据会被编码成以```&```分隔的键值对，字符以URL编码方式编码

对于**```multipart/form-data```**而言，请求头中的```Content-Type```字段会包含```boundary```，且boundary的值有浏览器默认指定，数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上```--```表示结束

```multipart/form-data```格式最大的特点在于*每一个表单元素都是独立的资源表述*
另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。

在实际的场景中，对于图片等文件的上传，基本采用```multipart/form-data```而不用```application/x-www-form-urlencoded```，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间

##### 4.2.3 内容协商（Accept系列字段）

数据格式、字符集、压缩方式、支持语言

> 首部字段（接收端|发送端）

- Accept|Content-Type
- Accept-Charset|Content-Type
- Accept-Encoding|Content-Encoding
- Accept-Language|Content-Language

1. 数据格式
   HTTP 从```MIME type```取了一部分来标记报文 body 部分的数据类型，体现在```Content-Type|Accept```字段
   这两个字段的取值可以分为下面几类:

   - text：```text/html, text/plain, text/css``` 等
   - image: ```image/gif, image/jpeg, image/png ```等
   - audio/video: ```audio/mpeg, video/mp4 ```等
   - application: ```application/json, application/javascript, application/pdf, application/octet-stream```

   > MIME(Multipurpose Internet Mail Extensions, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。

2. 字符集

   ```
   // 发送端
   Content-Type: text/html; charset=utf-8
   // 接收端
   Accept-Charset: charset=utf-8
   ```

3. 压缩方式

   见编码压缩

4. 支持语言

   ```zh-CN, zh, en```

协商类型

- 服务器驱动
- 客户端驱动协商
- 透明协商

##### 4.2.4 状态码

状态码负责表示客户端请求的返回结果、标记服务器端是否正常、通知出现的错误

| 类别 | 原因短语                         |
| :--: | :------------------------------- |
| 1XX  | Information（信息性状态码）      |
| 2XX  | Success（成功状态码）            |
| 3XX  | Redirection（重定向）            |
| 4XX  | Client Error（客户端错误状态码） |
| 5XX  | Server Error（服务器错误状态码） |

**1XX** 临时回应 表示客户端请继续

- 101 在HTTP升级为```WebSocket```时，服务器同意变更即发送状态码101

**2XX成功**

- 200（OK）客户端发过来的数据被正常处理
- 204（Not Content）正常响应，没有实体
- 206（Partial Content）范围请求，返回部分数据，响应报文中由Content-Range指定实体内容，使用场景为HTTP分块下载和断电续传

**3XX重定向**

- 301（Moved Permanently）永久重定向，此时浏览器默认做缓存优化，再次访问时自动访问重定向的地址

- 302（Found）临时重定向，规范要求方法名不变，但是都会改变，浏览器不会做缓存优化

- 303（See Other）和302类似，但必须用GET方法

- 304（Not Modified）状态未改变，配合（If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since）——缓存

  协商缓存命中时：客户端本地已有缓存的版本，并在Request中告诉了服务端，当服务端通过时间或者tag发现没有更新时，就会返回不含body的304状态

- 307（Temporary Redirect）临时重定向，不该改变请求方法

**4XX客户端错误**

- 400（Bad Request）请求报文语法错误
- 401（Unauthorized）需要认证
- 403（Forbidden）服务器拒绝访问对应的资源（无权限）
- 404（Not Found）服务器上无法找到资源
- 405（Method Not Allowed）请求方法不被服务器端允许
- 406（Not Acceptable）资源无法满足客户端的条件
- 408 Request Timeout: 服务器等待了太长时间
- 409 Conflict: 多个请求发生了冲突
- 413 Request Entity Too Large: 请求体的数据过大
- 414 Request-URI Too Long: 请求行里的 URL 太大
- 429 Too Many Request: 客户端发送的请求过多
- 431 Request Header Fields Too Large 请求头的字段内容太大。

**5XX服务器端错误**

- 500（Internal Server Error）服务器故障
- 501 Not Implemented: 表示客户端请求的功能还不支持
- 502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
- 503（Service Unavailable）服务器处于超负载或正在停机维护

##### 4.2.5 首部

**通用首部字段**

**请求首部字段**

**响应首部字段**

**实体首部字段**



#### 4.3 HTTP特点及缺点

**HTTP 特点**

- 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。

- 可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。
- 请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。
- 无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

**HTTP 缺点**

- 无状态

  所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
  在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
  但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点

- 明文传输

  即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。
  这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。*WIFI陷阱*就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

- 队头阻塞问题

  当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的*队头阻塞*问题

##### 4.3.1 队头阻塞

HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。

HTTP1.1如何解决

- 并发连接

  对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务

  在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个

  但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

- 域名分片

  一个域名不是可以并发 6 个长连接吗？那我就多分几个域名，比如 content1.sanyuan.com 、content2.sanyuan.com
  这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题



#### 4.4 HTTPS

- 确定请求的目标服务端身份
- 保证传输的数据不会被网络中间节点窃听或者篡改

使用加密通道传输HTTP内容，首先与服务器端建立一条TLS加密通道，传输内容与HTTP没有区别



#### 4.4 Web服务器

##### 4.3.1 虚拟主机（Virtual Host）

一台HTTP服务器上搭建多个Web站点，客户端发送请求时必须在Host首部完整指定主机名或域名的URL

##### 4.3.2 代理、网关——通信转发程序

**4.3.2.1 代理**

代理就是客户端和服务器的中间人

**作用**

- 利用缓存技术减少网络流量
- 组织内部针对网站进行访问控制
- 获取访问日志

**分类**

- 缓存代理 会预先把资源副本保存在服务器上
- 透明代理 不对报文进行任何加工

**4.3.2.2 网关**

接收从客户端发送来的数据时，会转发给其他服务器处理，再由自己返回

- 使通信线路上的服务器提供非HTTP协议服务
- 提高通信安全性



FTP文件传输协议

SMTP（发送邮件）和POP3（接收邮件）



 ### 案例(wareshark)

数据->传输层（包）->网络层（段Segment）->数据链路层（帧）

#### 发送方是从高层到低层封装数据

- 在**应用层**要把各式各样的数据如字母、数字、汉字、图片等转换成二进制
- 在**传输层**中，上层的数据被分割成小的数据段，并为每个分段后的数据封装TCP报文头部
- 在TCP头部有一个关键的字段信息端口号，它用于标识上层的协议或应用程序，确保上层数据的正常通信
- 计算机可以多进程并发运行，例如在发邮件的同时也可以通过浏览器浏览网页，这两种应用通过端口号进行区分
- 在**网络层**，上层数据被封装上报文头部（IP头部），IP头部包括的最关键字段信息就是IP地址，用于标识网络的逻辑地址
- 在**数据链路层**，上层数据装上MAC头部，内部有最关键的MAC地址，即固化在硬件设备内部的全球唯一的物理地址
- 在**物理层**，无论在之前哪一层封装的报文头还是上层数据都是由二进制组成，这些二进制数字比特流转换成电信号在网络中传输

![封装数据](./src/封装数据.drawio.png)

#### 接收方是从低层到高层解封装

- 数据封装完毕传输到接收方后，要将数据进行解封装
- 在物理层，先把电信号转成二进制数据，并将数据传送至数据链路层
- 在数据链路层，把MAC头部拆掉，并将剩余的数据传送至上一层
- 在网络层，数据的IP头部被拆掉，并将剩余的数据送至上一层
- 在传输层，把TCP头部拆掉，将真实的数据传送至应用层

![解封装](./src/解封装.drawio.png)

#### 真实网络环境

- 发送方和接收方中间可能会有多个硬件中转设备
- 中间可能会增加交换机（数据链路层）和路由器（网络层）
- 数据在传输过程中不断地进行封装和解封装的过程，每层设备只能处理那一层的数据