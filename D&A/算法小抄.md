## 递归

定义：此函数干什么？

状态：函数参数中的变量是什么？

选择：得到递归结果要干什么？

当前root节点要干什么



## 数组

**迭代遍历**

```javascript
function traverse(arr) {
    for(let i = 0; i < arr.length; i++) {
        // 迭代访问arr[i]
    }
}
```



## 链表

```javascript
function ListNode(val) {
    this.val = val;
    this.next = null;
}
```



## 双指针

### 快慢指针——链表



### 左右指针——数组、字符串

#### 二分查找

```javascript
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;

    // 查找区间 [left, right]
    while(left <= right) {
        let mid = Math.floor((left + right) / 2) ;
        if(nums[mid] == target) {
            //
            return mid;
        } else if(nums[mid] < target) {
            // left = ...
            left = mid + 1;
        } else if(nums[mid] > target) {
            // right = ...
            right = mid - 1;
        }
    }

    return -1;
};
```



#### 滑动窗口

1. 使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引左闭右开区间 `[left, right)` 称为一个「窗口」
2. 先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）
3. 停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了），同时，每次增加 `left`，我们都要更新一轮结果
4. 重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头



## 动态规划

动态规划问题的一般形式就是<u>求最值</u>，求解动态规划的核心问题是<u>穷举</u>

重叠子问题、最优子结构、状态转移方程就是<u>动态规划三要素</u>

要符合「最优子结构」，子问题间必须互相独立

思考**状态转移方程**：

*明确 ```base case``` -> 明确「状态」-> 明确「选择」 -> 定义 ```dp```数组 /函数的含义*

- ```base case```

- **状态**（节点）：原问题和子问题中会变化的变量
- **选择**（路径）：导致「状态」产生变化的行为
  -  `dp` 函数/数组：一般来说函数的输入参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量

1. 暴力递归：状态转移方程

   > 优化：

2. 带备忘录的递归解法（*自顶向下*将存在冗余的递归树剪枝从而改造成不存在冗余的递归图）

3. ```dp```数组的迭代解法（*自底向上*使用```dp table```来消除重叠子问题）

4. 「状态压缩」如果发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据

### 框架

```python
# dp数组初始化、base case
dp[0][0][...] = base
# 进行状态转移——做选择、求最值
for 状态1 in 状态1的所有取值：
	for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

```python
# 备忘录
memo = dict()

def dp(「状态n」):
    # 查备忘录，避免重复计算
    if n in memo: return memo[n]
    # 返回结果初始化、base case
    res = base
    # 进行状态转移——做选择、求最值
    for 状态1 in 状态1的所有取值：
   	 	for 状态2 in 状态2的所有取值：
        	for ...
            	res = 求最值(选择1，选择2...) # k个选择
    # 记入备忘录
    memo[n] = res
    return res;   	
```

子问题数目为 O(n)，处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(`kn`)



最长公共子序列：解决两个字符串的动态规划问题，一般都是用两个指针 `i,j` 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模



## 回溯算法（DFS）

解决一个回溯问题，实际上就是**一个决策树的遍历过程**。

思考 3 个问题：

1. 路径（<u>树枝</u>）：已经做出的选择
2. 选择列表：当前可以做的选择
3. 结束条件：到达决策树底层，无法再做选择的条件

可以把「路径」和「选择」列表作为决策树上每个<u>节点</u>的属性

`backtrack` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性——在前序遍历和后序遍历处做操作，即做选择和撤销选择；当触发「结束条件」时，将「路径」记入结果集

### 框架

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        # 做选择 - 将该选择从选择列表移除
        backtrack(路径, 选择列表)
        # 撤销选择 - 将该选择再加入选择列表
```

多叉树的遍历

```c++
void traverse(TreeNode root) {
    for (TreeNode child : root.childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}
```

前序遍历的代码在进入某一个节点之前的那个时间点执行
后序遍历代码在离开某个节点之后的那个时间点执行

时间复杂度就是这棵二叉树的节点数，为 `O(2^N)`



## 位运算

