## 动态规划

动态规划问题的*一般形式*就是**求最值**，求解动态规划的核心问题是**穷举**

**重叠子问题**、**最优子结构**、**状态转移方程**就是动态规划三要素

思考状态转移方程：

*明确 ```base case``` -> 明确「状态」-> 明确「选择」 -> 定义 ```dp```数组 /函数的含义*

### 框架

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

### 范例

#### [509. 斐波那契数](src/509.md)

**带备忘录的递归解法**

**```dp``` 数组的迭代解法**

「**状态压缩**」



## 回溯算法（DFS）

解决一个回溯问题，实际上就是**一个决策树的遍历过程**。

思考 3 个问题：

1. 路径：已经做出的选择
2. 选择列表：当前可以做的选择
3. 结束条件：到达决策树底层，无法再做选择的条件

### 框架

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        # 做选择 - 将该选择从选择列表移除
        backtrack(路径, 选择列表)
        # 撤销选择 - 将该选择再加入选择列表
```

多叉树的遍历

```c++
void traverse(TreeNode root) {
    for (TreeNode child : root.childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}
```

前序遍历的代码在进入某一个节点之前的那个时间点执行
后序遍历代码在离开某个节点之后的那个时间点执行



### 范例

#### [46. 全排列](src/46.md)

#### N皇后

